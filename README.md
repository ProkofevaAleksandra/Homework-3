# Homework-3

# Сравнительный анализ производительности Java коллекций.

# Сравнение MyLinkedList и java.util.LinkedList.

![1 1](https://user-images.githubusercontent.com/92428972/143219597-c1ee903f-fc2f-4ac8-a626-cf88388eff0d.PNG)
![1 2](https://user-images.githubusercontent.com/92428972/143219752-ffbe5c72-3e35-429f-8513-a5d6740489a6.PNG)
![1 3 1](https://user-images.githubusercontent.com/92428972/143219755-92d9677e-d8d3-4408-9105-00b4a44eaecc.PNG)
![1 3 2](https://user-images.githubusercontent.com/92428972/143219760-57cde09c-cfc1-4f0b-afb2-6491e760e20e.PNG)

       По результатам сравнительного анализа можно сделать вывод, что собственно реализованная коллекция MyLinkedList имеет такое же время добавления элементов, что и java.util.LinkedList. 
       Вставка элементов в MyLinkedList коллекцию происходит немного быстрее, если мы имеем небольшое количество элементов и чуть медленнее, чем в и java.util.LinkedList, если мы имеем большое количество элементов (более 30000).
       Удаление в коллекции MyLinkedList производится намного быстрее, чем в и java.util.LinkedList при любом количестве элементов.
       

# Сравнение ArrayList и LinkedList.

![2 1](https://user-images.githubusercontent.com/92428972/143219837-a0d334a2-a4c7-4349-8dc9-2df11a782925.PNG)
![2 2](https://user-images.githubusercontent.com/92428972/143219852-ee2a3b60-d16b-47bd-ba2c-a3ce3ab11970.PNG)
![2 3](https://user-images.githubusercontent.com/92428972/143219856-0e5a92de-5e13-4aea-b78e-68b9700d33a3.PNG)

       Доступ по индексу происходит очень быстро в ArrayList, так как построен он на базе массива. А добавление элементов в середину списка происходит медленно, т.к. нужно будет подвинуть каждый элемент, который идёт после, следовательно, для добавления (вставки) элементов в середину и конец списка удобно использовать LinkedList, что и показывает график времени работы. 
       Удаление элементов в ArrayList производится чуть быстрее, чем в LinkedList при любом количестве элементов. 

# Сравнение HashSet и LinkedHashSet и TreeSet.

![3 1](https://user-images.githubusercontent.com/92428972/143219893-a45900fc-ab85-4339-bc29-90f55d9a7d9c.PNG)
![3 2](https://user-images.githubusercontent.com/92428972/143219896-62109f96-b486-49da-bc5d-f6211c982c62.PNG)
![3 3](https://user-images.githubusercontent.com/92428972/143219902-79099616-aeba-4212-82a4-89b0738e34de.PNG)


       По результатам сравнительного анализа можно сделать вывод, что для быстрого добавления элементов следует использовать HashSet. Для быстрого поиска стоит использовать LinkedHashSet, так как сохраняется порядок добавления элементов. TreeSet следует использовать, если мы хотим получить отсортированный набор элементов. 
       Удаление элементов в LinkedHashSet производится быстрее при небольшом наборе элементов. При большом наборе быстрее у HashSet.
       Поэтому если хотим сохранить порядок добавления элементов - используем LinkedHashSet, а если хотим получить отсортированный набор - тогда используем TreeSet.


# Сравнение HashMap и LinkedHashMap и TreeMap.

![4 1](https://user-images.githubusercontent.com/92428972/143219917-4d1b95ba-d8d2-424b-a2e7-9869848616d3.PNG)
![4 2](https://user-images.githubusercontent.com/92428972/143219921-97c7157e-19f0-432a-a405-706f4d3ed86b.PNG)
![4 3](https://user-images.githubusercontent.com/92428972/143219924-b7db3ae7-784e-4ba5-be6c-7b7292f17b92.PNG)

 
       По результатам сравнительного анализа можно сделать вывод, что для быстрого добавления и поиска элементов следует использовать LinkedHashMap, так как сохраняется порядок добавления элементов. TreeSet следует использовать, если мы хотим получить отсортированный набор элементов. 
       Удаление элементов в HashMap производится быстрее при небольшом наборе элементов. При большом наборе быстрее у LinkedHashMap.
       Поэтому если хотим сохранить порядок добавления элементов - используем LinkedHashMap, а если хотим получить отсортированный по ключам набор - тогда используем TreeMap.


      

